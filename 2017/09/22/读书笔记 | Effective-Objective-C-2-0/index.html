<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Effective Objective C 读书笔记整理">
<meta property="og:type" content="article">
<meta property="og:title" content="读书笔记 | Effective Objective C 2.0">
<meta property="og:url" content="http://yoursite.com/2017/09/22/读书笔记 | Effective-Objective-C-2-0/index.html">
<meta property="og:site_name" content="Cooler&#39;s Home">
<meta property="og:description" content="Effective Objective C 读书笔记整理">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/pasted-13.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-14.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-15.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-16.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-17.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-18.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-19.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-20.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-21.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-22.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-23.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-24.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-25.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-26.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-27.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-28.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-29.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-30.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-31.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-32.png">
<meta property="og:updated_time" content="2017-09-22T07:10:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记 | Effective Objective C 2.0">
<meta name="twitter:description" content="Effective Objective C 读书笔记整理">
<meta name="twitter:image" content="http://yoursite.com/images/pasted-13.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/22/读书笔记 | Effective-Objective-C-2-0/"/>





  <title>读书笔记 | Effective Objective C 2.0 | Cooler's Home</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cooler's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">日积月累</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-首页"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-关于我"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-标签"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-分类"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-归档"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/22/读书笔记 | Effective-Objective-C-2-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HoCooler">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avartar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooler's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">读书笔记 | Effective Objective C 2.0</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-22T11:10:56+08:00">
                2017-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Effective Objective C 读书笔记整理</p>
<a id="more"></a>
<h1 id="第一章-了解OC"><a href="#第一章-了解OC" class="headerlink" title="第一章 了解OC"></a>第一章 了解OC</h1><h2 id="第一条"><a href="#第一条" class="headerlink" title="第一条"></a>第一条</h2><table>
<thead>
<tr>
<th style="text-align:left">**</th>
<th style="text-align:center">OC</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">关系</td>
<td style="text-align:center">C的超集，添加面向对象</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">语法</td>
<td style="text-align:center">消息结构，运行的代码依赖于运行环境    函数调用，运行代码</td>
<td style="text-align:center">编辑器（多态：运行时决定，通过虚函数表）</td>
</tr>
<tr>
<td style="text-align:left">性能</td>
<td style="text-align:center">替换运行时组件</td>
<td style="text-align:center">重新编译</td>
</tr>
<tr>
<td style="text-align:left">内存</td>
<td style="text-align:center">所有的对象都分配在堆上，不能分配在栈上</td>
</tr>
</tbody>
</table>
<p>关于内存：</p>
<p>与C++不同，OC不允许将OC对象的内存分配到栈(stack)上，只能分配到堆(heap)上。</p>
<pre><code>C++     string str = &quot;123&quot;; 合法
OC      NSString str = @&quot;123&quot;;非法
OC      NSString *str = @&quot;123&quot;;合法
</code></pre><p>所以，OC对象需要指针，ARC也只是针对OC对象（堆上的内存）进行管理，分配在栈上的内存，系统自动清理。</p>
<h2 id="第二条"><a href="#第二条" class="headerlink" title="第二条"></a>第二条</h2><ul>
<li>向前声明 @class 的好处：<ul>
<li>1、是延迟引入，减少类的使用者所需的引入的头文件数量</li>
<li>2、解决类之间的相互引用</li>
</ul>
</li>
<li>#import VS #include : 避免循环引用如果类需要遵从协议，可以在class-continuation分类中）</li>
</ul>
<h2 id="第三条：多用字面量（语法糖）"><a href="#第三条：多用字面量（语法糖）" class="headerlink" title="第三条：多用字面量（语法糖）"></a>第三条：多用字面量（语法糖）</h2><ul>
<li>优势：<ul>
<li>1、简单、易读、防Nil；特别是NSArray、NSDictionary生成时遇到nil会报错，可以提前排查出问题</li>
</ul>
</li>
<li>局限：<ul>
<li>1、生成不变量，如果需要可变量，需要mutbleCopy；</li>
<li>2、也紧紧局限Foudation框架</li>
</ul>
</li>
</ul>
<h2 id="define-VS-类型变量"><a href="#define-VS-类型变量" class="headerlink" title="#define VS 类型变量"></a>#define VS 类型变量</h2><ul>
<li>#define 预处理，直接替换，不包含类型变量</li>
<li>类型变量：包含类型<ul>
<li>static : 作用域只在当前编译单元（.M）</li>
<li>const ： 不可变</li>
<li>在全局变量中，不添加static, 编译器会自动添加外部符号(extern symbol)，如果其他文件中也这样定义，会出现重定义，如果需要不同文件中公用变量，需要在.m中进行定义，在.h中添加extern</li>
</ul>
</li>
</ul>
<h2 id="第五条：枚举"><a href="#第五条：枚举" class="headerlink" title="第五条：枚举"></a>第五条：枚举</h2><ul>
<li>1、用枚举表示状态、选项、状态码</li>
<li>2、枚举值可能同时使用，定义为2的幂，可位或 组合使用</li>
<li>3、NS_ENUM and NS_OPTIONS （宏定义，根据不同模式，选择不同方式） 指明类型，不会采用编译器默认的类型，起到一定保护作用</li>
<li><p><del>4、枚举类型 switch 不添加default，这样添加新枚举类型时，会提示错误。</del></p>
<p>只是会未枚举的类型，但是也需要进行Default</p>
</li>
</ul>
<h1 id="第二章-对象、消息、运行时"><a href="#第二章-对象、消息、运行时" class="headerlink" title="第二章 对象、消息、运行时"></a>第二章 对象、消息、运行时</h1><h2 id="第六条："><a href="#第六条：" class="headerlink" title="第六条："></a>第六条：</h2><ul>
<li>实例变量：_someProperty，可通过偏移量访问数据</li>
<li><p>属性：实例变量+存取方法+属性特质：通过点语法可以读取设置属性；</p>
<ul>
<li>属性会自动生成_property的实例变量，可以通过@synthesize 设置实例变量别名，@dymanic则不自动生成实例变量+存取方法，编译器不会报错，会在运行时找到相关的变量和方法（NSManagerObject）</li>
<li><p>属性可以分为4类：原子性、读写权限、内存管理语义、方法名</p>
<p>其中需要特别指出的是copy<br>在定义NSString、NSArray、NSDictionary等支持copy协议，且存在可变类型（比如NSMutableString），属性需要设置为copy，防止一个NSMutableString赋值给属性时，属性就为可修改的<br>同样NSMutableArray，在设置属性时，需要设置为strong，考虑copy的语义</p>
</li>
<li><p>在初始化时：1、copy的属性，建议在初始化时就copy形参 2、在init方法中不建议用存取方法</p>
<pre><code>- (instancetype)initWithname:(NSString *)name
{
self = [super init];
if (self) {
    _name = [name copy]
}
return self;
}
</code></pre></li>
</ul>
</li>
</ul>
<p>ios开发atomic不能保证真正的原子，如果需要锁，需要更深层的锁定机制，出于性能一般都用nonatomatic.MAC OS X 则无此瓶颈.</p>
<h2 id="第7条：-直接访问变量-VS-存取方法"><a href="#第7条：-直接访问变量-VS-存取方法" class="headerlink" title="第7条： 直接访问变量 VS 存取方法"></a>第7条： 直接访问变量 VS 存取方法</h2><ul>
<li>直接访问<ul>
<li>1、直接访问速度更快，无需方法派发</li>
<li>2、直接访问，不会调用设置方法，copy属性，不会拷贝属性，而且保留新值释放旧值</li>
<li>3、不能KVO</li>
<li>4、不便于调试</li>
</ul>
</li>
<li>存取方法：<ul>
<li>1、init中不要用存取方法，防止子类覆盖</li>
<li>2、惰性初始化一定要用存取方法</li>
</ul>
</li>
</ul>
<h2 id="第8条"><a href="#第8条" class="headerlink" title="第8条"></a>第8条</h2><p>== 判断指针是否相等， isEqualTo判断类型、属性和hash值 （isEqual会根据类，进行方法分发，工厂方法），在复写isEqual方法时，需要注意其他情况调用super<br>关于hash值：如果collection类型的属性，直接写死固定值，会造成该固定值的对应的value变多，而影响性能。如果通过整体求hash，也出现中间变量，存在性能损耗。可以多每个属性求hash，在进行与或处理</p>
<p>注意：把对象放入collection之后，改变其内容会造成很严重的后果</p>
<pre><code>{1, 2} -&gt; NSSet *set // {{1, 2}}
{1} -&gt; NSMutableArray *array
array - &gt; set // {{1}, {1, 2}}
{2} -&gt; array
set //{{1,2}, {1, 2}}
set -&gt; NSSet NewSet //{{1, 2}}
</code></pre><h2 id="第9条-类族"><a href="#第9条-类族" class="headerlink" title="第9条 类族"></a>第9条 类族</h2><p>Cocoa里面很多类族实现，这种工厂方式的实现，因此不能用[subA class] == [A class]的方式进行判断，应该使用类型查询方式isKindOfClass进行类型判断。</p>
<h2 id="第10条-关联对象"><a href="#第10条-关联对象" class="headerlink" title="第10条 关联对象"></a>第10条 关联对象</h2><p>objc_setAssociateObject objc_getAssociateObject objc_removeAssociateObject</p>
<p>与Dictionary比较 设置关联对象的key一般是“不透明指针”，所以用静态全局变量作为key；同时要指定内存管理语义，用于模仿拥有 和 非拥有关系</p>
<h2 id="第11条-objc-msgSend"><a href="#第11条-objc-msgSend" class="headerlink" title="第11条 objc_msgSend"></a>第11条 objc_msgSend</h2><ul>
<li><p>消息由接受者、选择子、参数组成，给对象发送消息，相当于对象调用方法</p>
</li>
<li><p>每个类都有一张函数调用表，key为选择子，value为实际调用的函数值。尾调用优化技术，使跳转更加简单：直接跳转，不需要调用堆栈，进行优化。</p>
</li>
</ul>
<h2 id="第12条-消息转发"><a href="#第12条-消息转发" class="headerlink" title="第12条 消息转发"></a>第12条 消息转发</h2><p><img src="/images/pasted-13.png" alt="upload successful"></p>
<p>对象将无法解读的选择子交给其他对象处理，可以模拟多重集成的</p>
<h2 id="第13条-method-swizzing"><a href="#第13条-method-swizzing" class="headerlink" title="第13条 method swizzing"></a>第13条 method swizzing</h2><p><img src="/images/pasted-14.png" alt="upload successful"></p>
<h2 id="第14条-理解类对象"><a href="#第14条-理解类对象" class="headerlink" title="第14条 理解类对象"></a>第14条 理解类对象</h2><p>继承是通过super_class, 元类是通过isa</p>
<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<p>类对象是单例，可以用==，来判断内存是否相等</p>
<p><img src="/images/pasted-16.png" alt="upload successful"></p>
<h1 id="第三章-接口和API设计"><a href="#第三章-接口和API设计" class="headerlink" title="第三章 接口和API设计"></a>第三章 接口和API设计</h1><h2 id="第15条：用前缀避免命名空间冲突"><a href="#第15条：用前缀避免命名空间冲突" class="headerlink" title="第15条：用前缀避免命名空间冲突"></a>第15条：用前缀避免命名空间冲突</h2><h2 id="第16条："><a href="#第16条：" class="headerlink" title="第16条："></a>第16条：</h2><p>提供“全能初始化方法”:designated initializer OR Initializer from NSCoding；子类与超类不同，子类需要覆盖，超类需要在方法中写Assert</p>
<h2 id="第17条-实现description-amp-amp-debugDescription"><a href="#第17条-实现description-amp-amp-debugDescription" class="headerlink" title="第17条 实现description &amp;&amp; debugDescription"></a>第17条 实现description &amp;&amp; debugDescription</h2><h2 id="第18条-尽量使用不可变对象"><a href="#第18条-尽量使用不可变对象" class="headerlink" title="第18条 尽量使用不可变对象"></a>第18条 尽量使用不可变对象</h2><ul>
<li><p>1、.h 中readonly, .m中readwrite，</p>
<p>但是在对象外面还可以通过KVC的方式（setValue forKey）进行更改(hack)；更加brutal 是通过类型查询信息找到对应实例变量在内存中的偏移量，从而进行设置</p>
</li>
<li>2、可变的collection，应该通过相关方法，修改可变对象</li>
</ul>
<h2 id="第19条-使用清晰而协调的命名方式"><a href="#第19条-使用清晰而协调的命名方式" class="headerlink" title="第19条 使用清晰而协调的命名方式"></a>第19条 使用清晰而协调的命名方式</h2><h2 id="第20条"><a href="#第20条" class="headerlink" title="第20条"></a>第20条</h2><p>为私有方法添加前缀，但是不要单用一个下划线，这是预留苹果公司用的</p>
<h2 id="第21条-理解OC的错误类型"><a href="#第21条-理解OC的错误类型" class="headerlink" title="第21条 理解OC的错误类型"></a>第21条 理解OC的错误类型</h2><p>ARC不是异常安全的，抛出异常，未释放的对象不能自动释放。如果想“异常安全”，增加-fobc-arc-exception标志；</p>
<p>严重错误，抛出NSException；不严重用nil，0、NSError</p>
<h2 id="第22条-理解NSCoping"><a href="#第22条-理解NSCoping" class="headerlink" title="第22条 理解NSCoping"></a>第22条 理解NSCoping</h2><p>—copyWithZone:(NSZone *)zone</p>
<p>复制对象一般进行浅拷贝，深拷贝可单独写一个方法。深拷贝会将底层数据一起拷贝，包括实例变量。</p>
<h1 id="第四章-协议与分类"><a href="#第四章-协议与分类" class="headerlink" title="第四章 协议与分类"></a>第四章 协议与分类</h1><p>分类是建立在OC运行时基础上的；协议一般用于委托模式</p>
<h2 id="第23条-通过委托与数据源进行对象间的通讯"><a href="#第23条-通过委托与数据源进行对象间的通讯" class="headerlink" title="第23条 通过委托与数据源进行对象间的通讯"></a>第23条 通过委托与数据源进行对象间的通讯</h2><ul>
<li>1、把需要处理的事件方法定义成协议</li>
<li>2、对象从另外一个对象获取数据时，定义成数据源协议</li>
<li>3、若有必要，可实现含有位段的结构体，将委托对象是否响应相关协议缓存其中,（直接在setDelegate方法中进行缓存）</li>
</ul>
<h2 id="第24条-通过分类方法-将类的实现代码分散到便于管理的多个分类中"><a href="#第24条-通过分类方法-将类的实现代码分散到便于管理的多个分类中" class="headerlink" title="第24条 通过分类方法 将类的实现代码分散到便于管理的多个分类中"></a>第24条 通过分类方法 将类的实现代码分散到便于管理的多个分类中</h2><ul>
<li>1、划分成不同的功能区</li>
<li>2、调试方便，因为分类名会出现在类名后面；</li>
<li>3、私有的可以考虑private分类</li>
</ul>
<h2 id="第25条-为第三方分类及方法添加前缀"><a href="#第25条-为第三方分类及方法添加前缀" class="headerlink" title="第25条 为第三方分类及方法添加前缀"></a>第25条 为第三方分类及方法添加前缀</h2><p>如果二个分类提供的方法重名，后编译分类方法会覆盖前面分类方法，分类编译顺序与添加到工程中的顺序有关；如果方法名相同，分类会覆盖苹果自带的方法</p>
<h2 id="第26条-不要在分类中申明属性"><a href="#第26条-不要在分类中申明属性" class="headerlink" title="第26条 不要在分类中申明属性"></a>第26条 不要在分类中申明属性</h2><p>不要再分类中声明属性（class-continuation除外），虽然技术上可行。如果声明，会出现warning，原因是分类中无法合成与声明属性相关的变量，所以需要在分类中实现存取方法，并且实现中声明为@dynamic，意思就运行时在提供。当然关联对象也可以实现这种需求，但是仍然建议只在分类中提供方法</p>
<h2 id="第27条-使用class-continuation隐藏实现细节"><a href="#第27条-使用class-continuation隐藏实现细节" class="headerlink" title="第27条 使用class-continuation隐藏实现细节"></a>第27条 使用class-continuation隐藏实现细节</h2><p>为什么要有这种分类：因为可以定义方法和实例变量。</p>
<p>隐藏实例方法和方法，也可以避免不必要头文件的引入，特别是对于OC++而言，引入的C++头文件。这样.h中进行向前声明，避免引入不必要的头文件，<br>也可以将类遵循的协议放在class-continuation，但是向前声明delegate却会有警告，因为引入.h文件，编译器看不到协议的定义及包含的方法。</p>
<p>为什么可以定义方法和实例变量：因为ABI机制，我们无须知道对象大小也可以使用。</p>
<p><img src="/images/pasted-17.png" alt="upload successful"></p>
<h2 id="第28条-通过协议提供匿名对象"><a href="#第28条-通过协议提供匿名对象" class="headerlink" title="第28条 通过协议提供匿名对象"></a>第28条 通过协议提供匿名对象</h2><p>如果具体类型不重要，只是能响应特定方法，那么可使用匿名对象表示，声明为id类型，来隐藏类型名称</p>
<h1 id="第五章-内存管理"><a href="#第五章-内存管理" class="headerlink" title="第五章 内存管理"></a>第五章 内存管理</h1><h2 id="第29条"><a href="#第29条" class="headerlink" title="第29条"></a>第29条</h2><p>1、对象创建出来引用计数至少为1，因为在alloc 或者init方法中，其他对象对其进行持有。（思考下面autorelease）</p>
<p>2、引用计数的跟对象是NSApplication 或者 UIApplication，都是在main函数中。</p>
<p>3、set方法中MRC的顺序 保留新的值，释放旧的值，在赋值。</p>
<pre><code>-（void）setFoo:(id)foo{
[foo retain];
[_foo release];
_foo = foo;
}
//这种情况下，如果foo 和 _foo是同一个值，就会出现问题
-（void）setFoo:(id)foo{
[_foo release];
_foo = [foo retain];
}
</code></pre><p>4、autorelease 延长对象生命期，在跨越方式调用便捷后依然存活一段时间。即会在稍后将引用计数减1，通常是下一个event loop，也可能更早（自动释放池会被释放）。这样就方便了函数调用返回对象不会被立即release或者无法release，导致内存泄露。</p>
<h2 id="第30条"><a href="#第30条" class="headerlink" title="第30条"></a>第30条</h2><p>ARC只负责OC对象的内管管理，CoreFoundation 对象 不归 ARC 管理，要进行手动CFRetian/CFRelease</p>
<p>ARC在调用下面方法（retain,release,autorelease,dealloc）是非法的，并且它并不是通过OC消息转发机制，而是直接通过底层C语言，性能更好，而且因为保留释放比较频繁，可以对其进行抵消，节省CPU周期。比如objc_autorrelaseReturnValue + retain = objc_RetainautoreleaseReturnValue;这一过程是可通过标志位完成</p>
<p>ARC命名规则：<br>alloc、new、copy、mutablecopy 生成的对象，要负责释放对象，而其他方法则不需要，会在方法最后添加auotorelease在稍微释放。</p>
<p>变量的内存管理语义：<br>ARC ：_objc = [SomeClass New];<br>MRC：id tmp = [SomeClass New]； _objc = [tmp retian]; [tmp release]；</p>
<p>ARC如何清理实例变量：通过OC++的cleanup routine，调用回收对象的析构函数.cxx_destruct方法，并且自动调用超类的dealloc方法</p>
<h2 id="第31条-在dealloc中只释放非OC对象引用并解除监听"><a href="#第31条-在dealloc中只释放非OC对象引用并解除监听" class="headerlink" title="第31条 在dealloc中只释放非OC对象引用并解除监听"></a>第31条 在dealloc中只释放非OC对象引用并解除监听</h2><p>运行时会在适当的时候调用dealloc，不要主动调用dealloc，但是手动 需要最后调用 super dealloc</p>
<p>1、开销较大或者系统内资源（比如文件描述符、套接字、大块内存等）不在dealloc中进行，应该单独提供方法进行释放，还有一个原因是系统并不保证每个创建出来的对象dealloc都会执行，也可以考虑在Appdelegate中种植方法执行清理，防止内存泄露</p>
<p>2、在dealloc不建议调用其他函数，防止调用过程中对象已经销毁。也不要调用属性的存取方法，因为有人会对其进行覆盖，也可能处于KVO下。（这个存取方法待讨论）</p>
<p>3、self.tableView.delegate 设置为nil</p>
<p>特别需要注意的是：<br>iOS 8 下tableView的 delegate 和 dataSource 是 assign的，如果不设置为nil会发生野指针crash</p>
<h2 id="第32条-编写异常安全的代码，留意内存管理问题"><a href="#第32条-编写异常安全的代码，留意内存管理问题" class="headerlink" title="第32条 编写异常安全的代码，留意内存管理问题"></a>第32条 编写异常安全的代码，留意内存管理问题</h2><p>MRC时，可以将内存释放写在finnal里面（提问：为什么不能写在try 和 catch 里面），但是变量就必须放在块的外面</p>
<p>ARC时：不会自动处理try catch的内存管理，因为ARC不能调用release，所以需要很多样板代码，进行跟踪清理对象，影响运行时性能。因为ios认为因为异常而终止程序，内存管理也就没有必要了。</p>
<p>1、通过-fobjc-arc-exceptions进行开启安全异常处理，默认情况是关闭的。OC++模式是默认开启的</p>
<p>2、建议通过NSError方式进行错误捕捉。</p>
<h2 id="第33条-以弱引用避免保留环"><a href="#第33条-以弱引用避免保留环" class="headerlink" title="第33条 以弱引用避免保留环"></a>第33条 以弱引用避免保留环</h2><p>垃圾回收（Garbage collector）会检查引用环，并且会将所有的引用对象都回收。但是ios从未支持过该功能</p>
<p>ARC weak引用会自动清理，由运行时系统来实现</p>
<h2 id="第34条"><a href="#第34条" class="headerlink" title="第34条"></a>第34条</h2><p>以自动释放块 降低内存峰值。特别是读取大块数据时，比如图像，数据库。</p>
<p>1、自动释放池存放在栈上，对象收到autorealease方法后，系统将其放在最顶端的池里</p>
<p>2、推荐@autoreleasepool，NSAutorelasePool 在MRC时，需要drain来进行释放，而且“比较重”</p>
<h2 id="第35条-僵尸对象调试-内存管理问题"><a href="#第35条-僵尸对象调试-内存管理问题" class="headerlink" title="第35条 僵尸对象调试 内存管理问题"></a>第35条 僵尸对象调试 内存管理问题</h2><p>当对象已经释放，但是还没被覆盖时，调用这块内存会正常工作，但是存在很大风险。Cocoa：系统在回收对象时，可以不真的将其回收，而是把它转化为僵尸对象。NSZombieEnabled设置为yes，或者在scheme中勾选。</p>
<p>僵尸类是从NSZombie模板复制出来的，并且可以保留原类名字，不采用继承的方式，是因为效率因素的考虑。</p>
<p><img src="/images/pasted-18.png" alt="upload successful"></p>
<p>其实现原理是：<br>修改对象的isa指针，让它指向僵尸类，使对象变成僵尸对象，僵尸类能影响所有的选择子：打印相关消息，并且终止程序。</p>
<p>创建新类，并且转化为僵尸对象：</p>
<p><img src="/images/pasted-19.png" alt="upload successful"></p>
<p>在消息转发机制中，forwarding相应所有的选择子</p>
<p><img src="/images/pasted-20.png" alt="upload successful"></p>
<h2 id="第36条-不要用retainCount，ARC后正式废弃"><a href="#第36条-不要用retainCount，ARC后正式废弃" class="headerlink" title="第36条 不要用retainCount，ARC后正式废弃"></a>第36条 不要用retainCount，ARC后正式废弃</h2><pre><code>while ([objc retianCount]) {
    [objc release]
} 
</code></pre><p>1、objc可能会在后续自动释放，在此释放会crash</p>
<p>2、retainCount 可能永远不为0，系统优化释放行为，为1是就回收了。没有1到0的过程。</p>
<h1 id="第六章-块与大中枢派发"><a href="#第六章-块与大中枢派发" class="headerlink" title="第六章 块与大中枢派发"></a>第六章 块与大中枢派发</h1><h2 id="第37条：理解“块”"><a href="#第37条：理解“块”" class="headerlink" title="第37条：理解“块”"></a>第37条：理解“块”</h2><ul>
<li><p>1、块：只要有支持次特性的编译器以及能执行块的运行期组件，就可以在C、C++、OC、OC++中使用。（<code>待理解？？？</code>）</p>
</li>
<li><p>2、块定义，<a href="http://goshdarnblocksyntax.com/" target="_blank" rel="external">参考</a></p>
<blockquote>
<p>局部变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>&gt;<br>属性：<br>&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);</div></pre></td></tr></table></figure></p>
<p>&gt;<br>方法形参：<br>&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>实参：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;];</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;<br>typedef<br>&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef returnType (^TypeName)(parameterTypes);</div><div class="line">TypeName blockName = ^returnType(parameters) &#123;...&#125;;</div></pre></td></tr></table></figure></p>
<ul>
<li>3、关于捕获外部变量：运行块所需的全部信息都可以在编译期确定。而且是捕获栈上的变量，如果要修改栈上的变量，需要声明时，加__block</li>
</ul>
<p>如下，对象存在堆上，所以不需要加__block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    NSMutableArray *mutablArray = [NSMutableArray array];</div><div class="line">    void (^block)() = ^&#123;</div><div class="line">        [mutablArray addObject:@&quot;1&quot;];  // 1 OK</div><div class="line">//        mutablArray = [NSMutableArray array]; // 2 Error</div><div class="line">    &#125;;</div><div class="line">    block();</div></pre></td></tr></table></figure></p>
<p>注意：需要注意的是，在block内部中，_someInstance实际是self-&gt;_someInstance，因此也会捕获self</p>
<ul>
<li>4、块的内部结构</li>
</ul>
<p><img src="/images/pasted-21.png" alt="upload successful"><br>invoke 是指向函数实现</p>
<p>descriptor指向结构体：copy 、 dispose分别对应引用计数的+1和-1</p>
<ul>
<li>5、栈、堆、全局块<br>定义block的时候，所占内存都是在栈上的。（只是一般而言，如果定义成实例变量，那么就在堆上了）</li>
</ul>
<p><img src="/images/pasted-22.png" alt="upload successful"><br>VS<br><img src="/images/pasted-23.png" alt="upload successful"><br><code>自己尝试一下输出结果</code></p>
<p>定义的二个块只在if else 作用域内起作用，通过copy 复制到堆上，就成了带引用计数的对象了。可以在定义范围之外的地方使用。</p>
<p>全局块：不捕捉任何对象，运行时是无状态的。全局块的拷贝是个空操作，因为全局块不会被系统回收，相当于单例。这样的处理只是技术上的优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void (^block)() = ^&#123;</div><div class="line">       NSLog(@&quot;This is the block&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="第38条：为块创建typedef"><a href="#第38条：为块创建typedef" class="headerlink" title="第38条：为块创建typedef"></a>第38条：为块创建typedef</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return_type (^block_name)(parameters)</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>1、定义变量一样定义block </li>
<li>2、重构时如果给Block多增加参数，那么只需修改相应的块签名（typedef），其他引用block的地方也会自动报错，避免遗漏</li>
</ul>
<h2 id="第39条-用handler块降低代码分散程度"><a href="#第39条-用handler块降低代码分散程度" class="headerlink" title="第39条 用handler块降低代码分散程度"></a>第39条 用handler块降低代码分散程度</h2><ul>
<li>1、使用delegate 会使代码结构过于分散，可以直接只用回调块，使块和相关对象放在一起，避免通过delegate透传数据</li>
<li>2、通过handler，增加队列参数，决定放在哪个队列上。</li>
<li>3、Error块和Succes块 放在一起，可以处理返回结果中数据异常的情况 VS Error 和 Success分开处理，更加清晰。个人更加意向前者</li>
</ul>
<p>第40条 用块引用其所属对象避免出现保留环</p>
<ul>
<li>1、设计API时，可以考虑在调用完complete的块之后，将环中的某个对象设置为nil，解除环，避免API调用者没有处理保留环的问题。也可以通过weakify的方法。</li>
<li>2、API调用者可以通过weakify的方法，解除保留环的问题；</li>
</ul>
<h2 id="第41条-多用派发队列，少用同步锁"><a href="#第41条-多用派发队列，少用同步锁" class="headerlink" title="第41条 多用派发队列，少用同步锁"></a>第41条 多用派发队列，少用同步锁</h2><ul>
<li><p>1、派发队列更加单实现同步语义。<br>GCD之前，有2种方法：</p>
<ul>
<li>1、同步块 @synchrnoized（someObject）一般是对self创建锁，但是其中会涉及与self无关的代码，降低代码效率。</li>
<li>2、NSLock对象，通过[_lock lock] [lock unlock]加锁，解锁；NSRecuresiveLock 递归锁<br>同一个锁的同步块，顺序执行</li>
</ul>
<p><code>通过atomic 属性同步，这是通过synchrnoized的方式实现的？</code></p>
</li>
<li>2、同步和异步派发结合可以实现加锁机制一样的同步问题，但是却不阻塞异步派发的进程，但是仍然无法正确同步</li>
<li>3、使用同步队列及栅栏块可以令同步行为更加高效。</li>
<li>4、异步派发，需要拷贝块，因此异步派发不一定会比同步快，需要考虑拷贝块与执行块的时间</li>
</ul>
<h2 id="第42条-多用GCD，少用performSelector系列方法"><a href="#第42条-多用GCD，少用performSelector系列方法" class="headerlink" title="第42条 多用GCD，少用performSelector系列方法"></a>第42条 多用GCD，少用performSelector系列方法</h2><p><img src="/images/pasted-24.png" alt="upload successful"></p>
<ul>
<li>1、会发生warning，导致内存泄漏，因为编译器不知道调用什么选择子，方法签名、返回值，无法通过ARC对返回值进行管理。</li>
<li>2、选择子太过局限，返回类型（void或者id，不能是struct）和参数都有局限。</li>
<li>3、如果把任务放在指定线程执行，用GCD和块，毕竟块可以捕获外部变量。</li>
</ul>
<h2 id="第43条-GCD-VS-操作队列（NSOperation）"><a href="#第43条-GCD-VS-操作队列（NSOperation）" class="headerlink" title="第43条 GCD VS 操作队列（NSOperation）"></a>第43条 GCD VS 操作队列（NSOperation）</h2><p><img src="/images/pasted-25.png" alt="upload successful"></p>
<p>NSOperation 好处：</p>
<ul>
<li>1、取消操作 </li>
<li>2、指定依赖关系 </li>
<li>3、通过KVO监控NSoperation对象的属性</li>
<li>4、指定操作的优先级</li>
<li>5、可以复用NSOperation对象</li>
</ul>
<p>NSNotifationCenter 就是使用的操作队列</p>
<h2 id="第44条-使用dispatch-group进行任务分组"><a href="#第44条-使用dispatch-group进行任务分组" class="headerlink" title="第44条 使用dispatch group进行任务分组"></a>第44条 使用dispatch group进行任务分组</h2><ul>
<li>1、dispatch_group_async 包含block，用于回调</li>
<li>2、dispatch_group_enter &amp;&amp; dispatch_group_leave</li>
</ul>
<p>dispatch_group_wait （阻塞）使用表示group可以阻塞的时间；</p>
<p>dispatch_group_notify（不阻塞），使用group结束的回调。</p>
<p>dispatch_apply 用于重复执行的次数</p>
<h2 id="第45条-dispatch-once-只执行一次、线程安全"><a href="#第45条-dispatch-once-只执行一次、线程安全" class="headerlink" title="第45条 dispatch_once 只执行一次、线程安全"></a>第45条 dispatch_once 只执行一次、线程安全</h2><p>1、之前通过@synchronized(self) 创建单例，比dispatch-once慢二倍</p>
<p>2、需要一个标记，标记声明为static 或者global，目的是标记都相同</p>
<h2 id="第46条-不要使用dispatch-get-current-queue"><a href="#第46条-不要使用dispatch-get-current-queue" class="headerlink" title="第46条 不要使用dispatch_get_current_queue"></a>第46条 不要使用dispatch_get_current_queue</h2><p>1、dispatch_get_current_queue 已经废弃，只做调试用。最主要是也不准确，如下：</p>
<p><img src="/images/pasted-26.png" alt="upload successful"></p>
<p>2、派发队列是按照层次组织的，无法单用某个队列对象来描述当前队列这一概念（如上）</p>
<p>3、dispatch_get_current_queue可以解决不可重入代码引起的思索，一般用“队列特定数据”来解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_set_specific(dispatch_queue_t queue, const void *key,</div><div class="line">    void *_Nullable context, dispatch_function_t _Nullable destructor);</div><div class="line"></div><div class="line">void *_Nullable dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);</div></pre></td></tr></table></figure>
<p>用法具体见说明文档（补充链接）</p>
<p>与NSdictionary不同，更像 关联引用,值也是不透明的void指针，ARC很难进行管理，因此最后一个参数是析构函数</p>
<p><img src="/images/pasted-27.png" alt="upload successful"></p>
<h1 id="第七章-系统框架"><a href="#第七章-系统框架" class="headerlink" title="第七章 系统框架"></a>第七章 系统框架</h1><h2 id="第47条：熟悉系统框架"><a href="#第47条：熟悉系统框架" class="headerlink" title="第47条：熟悉系统框架"></a>第47条：熟悉系统框架</h2><p>Foundation OC语言：（CoreFoundation ： C语言）</p>
<p><img src="/images/pasted-28.png" alt="upload successful"></p>
<h2 id="第48条-多用块枚举，少用for循环，"><a href="#第48条-多用块枚举，少用for循环，" class="headerlink" title="第48条 多用块枚举，少用for循环，"></a>第48条 多用块枚举，少用for循环，</h2><ul>
<li>1、枚举方式：<br>1.1、for循环 1.2、NSEnumerator 遍历 1.3、快速遍历、块枚举</li>
<li>2、块枚举，支持GCD来并发执行遍历操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions) &#123;</div><div class="line">    NSEnumerationConcurrent = (1UL &lt;&lt; 0),</div><div class="line">    NSEnumerationReverse = (1UL &lt;&lt; 1),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果提前知道collection对象类型，应修改块签名，指出对象具体的类型</p>
<h2 id="第49条："><a href="#第49条：" class="headerlink" title="第49条："></a>第49条：</h2><p><img src="/images/pasted-29.png" alt="upload successful"></p>
<h2 id="第50条："><a href="#第50条：" class="headerlink" title="第50条："></a>第50条：</h2><p><img src="/images/pasted-30.png" alt="upload successful"></p>
<h2 id="第51条："><a href="#第51条：" class="headerlink" title="第51条："></a>第51条：</h2><p><img src="/images/pasted-31.png" alt="upload successful"></p>
<h2 id="第52条："><a href="#第52条：" class="headerlink" title="第52条："></a>第52条：</h2><p><img src="/images/pasted-32.png" alt="upload successful"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/21/读书笔记 | 图解《HTTP》/" rel="next" title="读书笔记 | 图解《HTTP》">
                <i class="fa fa-chevron-left"></i> 读书笔记 | 图解《HTTP》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/22/iOS SDK 更新总结 /" rel="prev" title="iOS SDK 新特性总结">
                iOS SDK 新特性总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avartar.jpg"
              alt="HoCooler" />
          
            <p class="site-author-name" itemprop="name">HoCooler</p>
            <p class="site-description motion-element" itemprop="description">iOS</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章-了解OC"><span class="nav-number">1.</span> <span class="nav-text">第一章 了解OC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一条"><span class="nav-number">1.1.</span> <span class="nav-text">第一条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二条"><span class="nav-number">1.2.</span> <span class="nav-text">第二条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三条：多用字面量（语法糖）"><span class="nav-number">1.3.</span> <span class="nav-text">第三条：多用字面量（语法糖）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#define-VS-类型变量"><span class="nav-number">1.4.</span> <span class="nav-text">#define VS 类型变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五条：枚举"><span class="nav-number">1.5.</span> <span class="nav-text">第五条：枚举</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-对象、消息、运行时"><span class="nav-number">2.</span> <span class="nav-text">第二章 对象、消息、运行时</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第六条："><span class="nav-number">2.1.</span> <span class="nav-text">第六条：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第7条：-直接访问变量-VS-存取方法"><span class="nav-number">2.2.</span> <span class="nav-text">第7条： 直接访问变量 VS 存取方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第8条"><span class="nav-number">2.3.</span> <span class="nav-text">第8条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第9条-类族"><span class="nav-number">2.4.</span> <span class="nav-text">第9条 类族</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第10条-关联对象"><span class="nav-number">2.5.</span> <span class="nav-text">第10条 关联对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第11条-objc-msgSend"><span class="nav-number">2.6.</span> <span class="nav-text">第11条 objc_msgSend</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第12条-消息转发"><span class="nav-number">2.7.</span> <span class="nav-text">第12条 消息转发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第13条-method-swizzing"><span class="nav-number">2.8.</span> <span class="nav-text">第13条 method swizzing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第14条-理解类对象"><span class="nav-number">2.9.</span> <span class="nav-text">第14条 理解类对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-接口和API设计"><span class="nav-number">3.</span> <span class="nav-text">第三章 接口和API设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第15条：用前缀避免命名空间冲突"><span class="nav-number">3.1.</span> <span class="nav-text">第15条：用前缀避免命名空间冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第16条："><span class="nav-number">3.2.</span> <span class="nav-text">第16条：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第17条-实现description-amp-amp-debugDescription"><span class="nav-number">3.3.</span> <span class="nav-text">第17条 实现description && debugDescription</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第18条-尽量使用不可变对象"><span class="nav-number">3.4.</span> <span class="nav-text">第18条 尽量使用不可变对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第19条-使用清晰而协调的命名方式"><span class="nav-number">3.5.</span> <span class="nav-text">第19条 使用清晰而协调的命名方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第20条"><span class="nav-number">3.6.</span> <span class="nav-text">第20条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第21条-理解OC的错误类型"><span class="nav-number">3.7.</span> <span class="nav-text">第21条 理解OC的错误类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第22条-理解NSCoping"><span class="nav-number">3.8.</span> <span class="nav-text">第22条 理解NSCoping</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章-协议与分类"><span class="nav-number">4.</span> <span class="nav-text">第四章 协议与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第23条-通过委托与数据源进行对象间的通讯"><span class="nav-number">4.1.</span> <span class="nav-text">第23条 通过委托与数据源进行对象间的通讯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第24条-通过分类方法-将类的实现代码分散到便于管理的多个分类中"><span class="nav-number">4.2.</span> <span class="nav-text">第24条 通过分类方法 将类的实现代码分散到便于管理的多个分类中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第25条-为第三方分类及方法添加前缀"><span class="nav-number">4.3.</span> <span class="nav-text">第25条 为第三方分类及方法添加前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第26条-不要在分类中申明属性"><span class="nav-number">4.4.</span> <span class="nav-text">第26条 不要在分类中申明属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第27条-使用class-continuation隐藏实现细节"><span class="nav-number">4.5.</span> <span class="nav-text">第27条 使用class-continuation隐藏实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第28条-通过协议提供匿名对象"><span class="nav-number">4.6.</span> <span class="nav-text">第28条 通过协议提供匿名对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-内存管理"><span class="nav-number">5.</span> <span class="nav-text">第五章 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第29条"><span class="nav-number">5.1.</span> <span class="nav-text">第29条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第30条"><span class="nav-number">5.2.</span> <span class="nav-text">第30条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第31条-在dealloc中只释放非OC对象引用并解除监听"><span class="nav-number">5.3.</span> <span class="nav-text">第31条 在dealloc中只释放非OC对象引用并解除监听</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第32条-编写异常安全的代码，留意内存管理问题"><span class="nav-number">5.4.</span> <span class="nav-text">第32条 编写异常安全的代码，留意内存管理问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第33条-以弱引用避免保留环"><span class="nav-number">5.5.</span> <span class="nav-text">第33条 以弱引用避免保留环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第34条"><span class="nav-number">5.6.</span> <span class="nav-text">第34条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第35条-僵尸对象调试-内存管理问题"><span class="nav-number">5.7.</span> <span class="nav-text">第35条 僵尸对象调试 内存管理问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第36条-不要用retainCount，ARC后正式废弃"><span class="nav-number">5.8.</span> <span class="nav-text">第36条 不要用retainCount，ARC后正式废弃</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-块与大中枢派发"><span class="nav-number">6.</span> <span class="nav-text">第六章 块与大中枢派发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第37条：理解“块”"><span class="nav-number">6.1.</span> <span class="nav-text">第37条：理解“块”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第38条：为块创建typedef"><span class="nav-number">6.2.</span> <span class="nav-text">第38条：为块创建typedef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第39条-用handler块降低代码分散程度"><span class="nav-number">6.3.</span> <span class="nav-text">第39条 用handler块降低代码分散程度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第41条-多用派发队列，少用同步锁"><span class="nav-number">6.4.</span> <span class="nav-text">第41条 多用派发队列，少用同步锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第42条-多用GCD，少用performSelector系列方法"><span class="nav-number">6.5.</span> <span class="nav-text">第42条 多用GCD，少用performSelector系列方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第43条-GCD-VS-操作队列（NSOperation）"><span class="nav-number">6.6.</span> <span class="nav-text">第43条 GCD VS 操作队列（NSOperation）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第44条-使用dispatch-group进行任务分组"><span class="nav-number">6.7.</span> <span class="nav-text">第44条 使用dispatch group进行任务分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第45条-dispatch-once-只执行一次、线程安全"><span class="nav-number">6.8.</span> <span class="nav-text">第45条 dispatch_once 只执行一次、线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第46条-不要使用dispatch-get-current-queue"><span class="nav-number">6.9.</span> <span class="nav-text">第46条 不要使用dispatch_get_current_queue</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-系统框架"><span class="nav-number">7.</span> <span class="nav-text">第七章 系统框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第47条：熟悉系统框架"><span class="nav-number">7.1.</span> <span class="nav-text">第47条：熟悉系统框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第48条-多用块枚举，少用for循环，"><span class="nav-number">7.2.</span> <span class="nav-text">第48条 多用块枚举，少用for循环，</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第49条："><span class="nav-number">7.3.</span> <span class="nav-text">第49条：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第50条："><span class="nav-number">7.4.</span> <span class="nav-text">第50条：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第51条："><span class="nav-number">7.5.</span> <span class="nav-text">第51条：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第52条："><span class="nav-number">7.6.</span> <span class="nav-text">第52条：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HoCooler</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
